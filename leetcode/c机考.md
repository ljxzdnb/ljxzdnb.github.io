# [c test](https://www.nowcoder.com/test/question/done?tid=59269593&qid=7640)

#### 3: main 函数执行以前，还会执行什么代码？

```
全局对象的构造函数在main函数之前调用，析构函数在main函数之后调用。
局部栈对象在定义的时候调用构造函数，出了可见范围的时候调用析构函数。
堆对象在new的时候调用构造函数，delete的时候调用析构。
全局静态对象和全局对象一样。
局部静态对象在定义的时候调用构造，main函数之后调用析构
```

#### 7:参加位运算的数据可以是任何类型的数据。请问这句话的说法是正确的吗？

```
十进制浮点数无法转化为精确的二进制浮点数
```

```c
union test {
    int x;
    char y;
    float z;
};
```

在 32 位平台上，这个联合的大小是（）字节

```
32 位机器上int为 4 字节、char 为 1 字节、float 为 4 字节。union 大小为 union 内最大元素的字节数。
```

请选择下列程序的执行结果（）

```c++
#include<iostream>
using namespace std;
class A{    
	public:   
	void f(){
	    cout<<"A::f()";
	}
};
class B: public A{    
	public:        
		void f(){
			cout<<"B::f()";
	        };
};
int main(){  
	B b;
	b.f();  
}
```

```
B::f()
```

‘：’右边表示这个函数和类这个作用域下的方法。主函数创建了B的对象，调用了f的方法，相当于执行了B，A这个函数被重载了，跟上一个A函数没关系

#### 11:声明一个引用的同时，如果不是作为函数的参数或返回值，必须进行初始化，明确引用是哪个变量的别名，引用一旦成为某个变量的别名后，在程序运行过程中不可改变这种指代关系。

#### 12:函数的形式参数隐含的存储类型说明是（）#auto

① auto  ： 既陌生又熟悉，因为它可以省略，比如 int  age;  在局部变量中，age的作用域就是当前局部变量的范围，一旦程序运行出当前域，则此变量被隐藏或自动释放。故我们一般都不用它。

②static  ： 静态变量，程序在第一次给它赋值后，即使变量所在函数执行完，它也不会被释放，这就是静态变量，它的生命周期等同于整个程序的运行周期。

③register  ： 寄存器型变量：这个关键字要求编译器尽可能的将变量存储在CPU内部寄存器中，而不是通过内存寻址访问，以提高效率。但是这只是给系统的一个暗示，如果寄存器资源有限，系统也不会满足你的要求。register型变量存取速度比内存快很多，一般你在一些系统库文件，或诸如单片机官方接口库中使用较多，正常我们能用上较少。 

④extern  :  外部变量：它属于变量声明，extern int a和int a的区别就是，前者告诉编译器，有一个int类型的变量a定义在其他地方，如果有调用请去其他文件中查找定义。

#### 13: 建立自定义函数的目的之一是（）提高程序的可读性

#### 14:设有定义: double array[10]; 表达式 sizeof(array)/sizeof(array[0])的结果是 array数组中元素个数。说法是否正确？

这题目有问题吧，它不是很严谨。如果是能容纳元素个数，就是正确的；

如果是已经容纳元素个数，那它就是错的。自己写一下很容易证明。

#### 18: 下列for循环的循环体执行次数为

```
for(int i=10, j=1; i=j=0; i++, j--)
```

这个问题可以这样理解，在for（string1;string2;string3）中，string1用于设定循环变量处置，string2用于循环判断，string3用于改变循环变量到调节，一般情况下，我们采用逻辑判断表达式来决定循环是否执行，而如果在这里采用赋值语句，其逻辑值始终为假，导致循环不执行

#### 19: 共同体变量所占的内存长度一定等于最长的成员的长度。请问这句话的说法是正确的吗？

union(共用体)的各个成员是以同一个地址开始存放的,每一个时刻只可以存储一个成员,这样就要求它在分配内存单元时候要满足两点: 
1.一般而言,共用体类型实际占用存储空间为其最长的成员所占的存储空间； 
2.若是该最长的存储空间对其他成员的元类型(如果是数组,取其类型的数据长度,例int a[5]为4)不满足整除关系,该最大空间自动延伸; 

上图char b[10]最长，10字节，然而不满足对int的整除，于是添加了2字节=12

#### 21:执行以下代码段(程序已包含所有必需的头文件)会输出什么结果。() 编译出错

```c
    char a[3];
    char b[] = "good";
    a = b;
    printf("%s", a);
```

a和b均为数组名，代表数组的首地址，无法相互赋值。

a是地址，不能直接赋值。如果想要赋值，可以把第三行代码改成*a=*b；此时第四行输出一个字母g

#### 25:下面代码在64位Linux系统编译执行，输出结果是____。40 8

```c
#include <stdint.h>
#include <stdio.h>

void print_size(int32_t array[10]) { printf("%d\n", sizeof(array)); }

int main() {
    int32_t myArray[10];
    printf("%d ", sizeof(myArray));
    print_size(myArray);
}
```

本题要注意几点：

1、sizeof(数组名），返回的整个数组占据的字节数。在这里，数组长度为10，每个4字节，所以，总共40字节。

2、在64位操作系统中，地址为64位，也就是指针64位，占8字节。

2、通过函数调用后，数组名退化成指针，占8字节。

#### 26: 以下代码的执行结果是(). 2147483647,-2147483648,-2147483647,2147483647

```c
#include<stdio.h>
int main(){
   int i = -2147483648;
   return printf("%d,%d,%d,%d", ~i, -i, 1 - i, -1 - i);
}
```

首先，求 **~i ，** i的补码为1000 0000 0000 0000 0000 0000 0000 0000，取反0111 1111 1111 1111 1111 1111 1111 1111，此为补码，符号位为0，表示正数，正数原码补码一致，因而该数即表示231-1，即**2147483647** 。

然后，求 **-i** ，要对一个数值执行单目运算符 -  表示的是对该数取反然后再+1，也即是我们常说的求补运算，注意这里取反+1与原码求补码的区别！也就是**求补运算与求补码是不一样的**！例子（4位有符号整数）：x=-4  1100（补码）  **-x=~x+1** 也即是 0011+0001=0100（4），而1100再求补码应是先数值位取反，即1011，然后+1，变成1100！注意这两者（求补与求补码）之间的区别。

首先，-2147483648这个数为32位int所能表示的最小负整数，而如果原码为 1000 0000 0000 0000 0000 0000 0000 0000（表示-0） ，其反码应为数值位取反，符号位不变，即1111 1111 1111 1111 1111 1111 1111 1111，

补码为反码+1 即为0 000 0000 0000 0000 0000 0000 0000 0000 （最高位溢出，舍去），

而+0 的原码、反码、补码均为 0 000 0000 0000 0000 0000 0000 0000 0000，

如果用 1000 0000 0000 0000 0000 0000 0000 0000作为 -2147483648的原码，则会导致 -2147483648和0的补码表示一样，因此，计算机中规定用 1000 0000 0000 0000 0000 0000 0000 0000来作为 -2147483648的补码，以确保**-2147483648~2147483647**都有唯一的补码表示；

**总结以上内容：正数的原码、反码、补码形式一致，负数的反码为原码的数值位取反，补码为反码+1也即是原码的数值位取反再+1，计算机中以补码表示数据和运算，而32位最小负整数的补码为** **1000 0000** **0000** **0000** **0000** **0000** **0000** **0000。**

然后回到本道题目的解答：

题目中 i的补码为 1000 0000 0000 0000 0000 0000 0000 0000，取反+1,**仍为** 1000 0000 0000 0000 0000 0000 0000 0000，即  **-2147483648**

求 **1-i** 我们已经求出-i的补码为1000 0000 0000 0000 0000 0000 0000 0000 加上1的补码即为 1000 0000 0000 0000 0000 0000 0000 0001

该补码表示的原码为1 111 1111 1111 1111 1111 1111 1111 1111，即为**-** **2147483647**

**最后求-1-i** -1的补码为1 111 1111 1111 1111 1111 1111 1111 1111，加上-i补码 1000 0000 0000 0000 0000 0000 0000 0000，

得 0111 1111 1111 1111 1111 1111 1111 1111，即 **2147483647**

另外补充一点，计算机中有符号数和无符号数的机器码（补码）是一样的，同一个二进制码按照有无符号输出结果不一样，例如本题中四个答案如果按照无符号整数输出，那么答案就是C

#### 27: 在64位操作系统上，下面程序返回结果是（）2400

```c
int main() {
    int *k[10][30];
    printf("%d\n", sizeof(k));
    return 0;
}
```

#### 28:在上下文及头文件均正常的情况下，以下代码打印的结果是（假设运行在 64 位计算机上）：

```c
struct st_t {
    int status;
    short *pdata;
    char errstr[32]; 
};
st_t st[16];
char *p = (char *)(st[2].errstr + 32);
printf("%d", (p - (char *)(st)));
```

st是由结构体初始化的，st[2]中包含有结构体中的成员{int status;short* pdata;char errstr[32];}而符号“.”就是对象调用成员的符号，即"."后面应该是对象的成员。

知道了这一点，题目就好理解了，st[2].**errstr**表示指向errstr的首地址，因为errstr占32位空间，所以(st[2].**errstr**+32)表示指向st[2].errstr的最后一个元素的下一个地址，即st[3]的首地址。

所以p-(char *)(st))，即为&st[3]-&st[0],占用空间为3个结构体的大小，即3\*48=144，

#### 29:下面程序的输出结果是

```c
char *p1 = "123", *p2 = "ABC", str［50］= "xyz";
strcpy(str + 2, strcat(p1, p2));
cout << str;
```

