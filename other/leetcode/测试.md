# 引用

引用就是对某一变量起了一个新别名，对引用的操作就是对其变量的操作；

int &a=b;//定义引用a,它是变量b的引用名即既是别名

1，引用方法  类型标识符（变量的类型）+&+引用名=目标变量名；

2，声明引用时必须对其初始化

3，声明一个引用并不是新定义一个变量，它只是一个引用名仅仅是变量的一个别名（一个引用名仅仅做为一个变量的引用），它不是一个数据类型，so它本身不占内存，系统也不给他分派内存空间

4，对引用求地址就是对变量求地址（&a=&b)

5,Because一个引用名仅仅是对一个变量的引用，同时数组是多个元素组成的集合，so无法建立一个数组的引用名

引用的应用

1，引用作为参数

```c++
void swap( &a,&b){
	int temp;
	temp=a;
	a=b;
	b=temp;}
   
main(){

int b,c;

cin>>b>>c;

swap(b,c);

cout <<b<<c;}
```

上述程序输入10，20则输出结果为20,10;

对被调函数的形参的操作就是主函数中目标对象参数的操作（和指针传递是等价的）

2，类型兼容原则的应用（需要基类对象的任何时候都可以用公有派生类的派生类对象来替代）

派生类对象可以初始化基类的引用

class A;

class B :: public A{....};

B  m;

A   &temp=m;//用派生类的对象初始化基类的引用

temp只能访问派生类对象从基类继承下的成员

# 你在做项目中有做过压力测试吗，怎么做

解题思路

1、首先对要测试的系统进行分析，明确需要对那一部分做压力测试，比如秒杀，支付

 2、如何对这些测试点进行施压 第一种方式可以通过写脚本产生压力机器人对服务器进行发包收报操作 第二点借助一些压力测试工具比如Jmeter,LoadRunner

 3、如何对这些测试点进行正确的施压 需要用压力测试工具或者其他方法录制脚本，模拟用户的操作

 4、对测试点设计多大的压力比较合适？ 需要明确压力测试限制的数量，即用户并发量

 5、测试结束后如何通过这些数据来定位性能问题 通过测试可以得到吞吐量，平均响应时间等数据，这个数据的背后是整个后台处理逻辑综合作用的结果，这时候就可以先关注系统的CPU，内存，然后对比吞吐量，平均响应时间达到瓶颈时这些数据的情况，然后就能确认性能问题是系统的哪一块造成的

# 请你说一下tcp和udp的区别

解题思路

1、TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接

2、TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保 证可靠交付

 3、TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流;

UDP是面向报文的，应用层交给UDP多长的报文，UDP就照样发送，即一次发送一个报文。

UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）

 4、每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信

 5、TCP首部开销20字节;UDP的首部开销小，只有8个字节

 6、TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道

# 请回答数组和链表的区别，以及优缺点，另外有没有什么办法能够结合两者的优点

解题思路

1.数组： 数组是将元素在内存中连续存放，由于每个元素占用内存相同，可以通过下标迅速访问数组中任何元素。但是如果要在数组中增加一个元素，需要移动大量元素，在内存中空出一个元素的空间，然后将要增加的元素放在其中。同样的道理，如果想删除一个元素，同样需要移动大量元素去填掉被移动的元素。如果应用需要快速访问数据，很少插入和删除元素，就应该用数组。 2.链表： 链表中的元素在内存中不是顺序存储的，而是通过存在元素中的指针联系到一起，每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针。如果要访问链表中一个元素，需要从第一个元素开始，一直找到需要的元素位置。但是增加和删除一个元素对于链表数据结构就非常简单了，只要修改元素中的指针就可以了。如果应用需要经常插入和删除元素你就需要用链表。

 3.区别： （1）存储位置上： 数组逻辑上相邻的元素在物理存储位置上也相邻，而链表不一定； （2）存储空间上： 链表存放的内存空间可以是连续的，也可以是不连续的，数组则是连续的一段内存空间。一般情况下存放相同多的数据数组占用较小的内存，而链表还需要存放其前驱和后继的空间。 （3）长度的可变性： 链表的长度是按实际需要可以伸缩的，而数组的长度是在定义时要给定的，如果存放的数据个数超过了数组的初始大小，则会出现溢出现象。 （4）按序号查找时，数组可以随机访问，时间复杂度为O(1)，而链表不支持随机访问，平均需要O(n)； （5）按值查找时，若数组无序，数组和链表时间复杂度均为O(1)，但是当数组有序时，可以采用折半查找将时间复杂度降为O(logn)； （6）插入和删除时，数组平均需要移动n/2个元素，而链表只需修改指针即可； （7）空间分配方面： 数组在静态存储分配情形下，存储元素数量受限制，动态存储分配情形下，虽然存储空间可以扩充，但需要移动大量元素，导致操作效率降低，而且如果内存中没有更大块连续存储空间将导致分配失败；即数组从栈中分配空间,，对于程序员方便快速,但自由度小。 链表存储的节点空间只在需要的时候申请分配，只要内存中有空间就可以分配，操作比较灵活高效；即链表从堆中分配空间, 自由度大但申请管理比较麻烦。 哈希表可以结合数组和链表的优点

# 请你回答一下测试的相关流程是什么？

解题思路

测试最规范的过程如下

需求测试->概要设计测试->详细设计测试->单元测试->集成测试->系统测试->验收测试 来自W模型

# 请你说一下如何写测试用例

解题思路

1、测试人员尽早介入，彻底理解清楚需求，这个是写好测试用例的基础

2、如果以前有类似的需求，可以参考类似需求的测试用例，然后还需要看类似需求的bug情况

3、清楚输入、输出的各种可能性，以及各种输入的之间的关联关系，理解清楚需求的执行逻辑，通过等价类、边界值、判定表等方法找出大部分用例

4、找到需求相关的一些特性，补充测试用例

5、根据自己的经验分析遗漏的测试场景

6、多总结类似功能点的测试点，才能够写出质量越来越高的测试用例

7、书写格式一定要清晰

# 请你说一说测试的常用方法

解题思路

**黑盒测试**： 黑盒测试也称功能测试或数据驱动测试，它是在已知产品所应具有的功能，通过测试来检测每个功能是否都能正常使用，在测试时，把程序看作一个不能打开的黑盆子，在完全不考虑程序内部结构和内部特性的情况下，测试者在程序接口进行测试，它只检查程序功能是否按照需求规格说明书的规定正常使用，程序是否能适当地接收输入数锯而产生正确的输出信息，并且保持外部信息（如数据库或文件）的完整性。 “黑盒”法着眼于程序外部结构、不考虑内部逻辑结构、针对软件界面和软件功能进行测试。“黑盒”法是穷举输入测试，只有把所有可能的输入都作为测试情况使用，才能以这种方法查出程序中所有的错误。实际上测试情况有无穷多个，因此不仅要测试所有合法的输入，而且还要对那些不合法但是可能的输入进行测试。 常用的黑盒测试方法有：等价类划分法；边界值分析法；因果图法；场景法；正交实验设计法；判定表驱动分析法；错误推测法；功能图分析法。

 **白盒测试**： 白盒测试也称为结构测试或逻辑驱动测试，是针对被测单元内部是如何进行工作的测试。它根据程序的控制结构设计测试用例，主要用于软件或程序验证。白盒测试法检查程序内部逻辑结构，对所有的逻辑路径进行测试，是一种穷举路径的测试方法，但即使每条路径都测试过了，但仍然有可能存在错误。因为：穷举路径测试无法检查出程序本身是否违反了设计规范，即程序是否是一个错误的程序；穷举路径测试不可能检查出程序因为遗漏路径而出错；穷举路径测试发现不了一些与数据相关的错误。 白盒测试需要遵循的原则有：1. 保证一个模块中的所有独立路径至少被测试一次；2. 所有逻辑值均需要测试真（true）和假（false）；两种情况；3. 检查程序的内部数据结构，保证其结构的有效性；4. 在上下边界及可操作范围内运行所有循环。 常用白盒测试方法： 静态测试：不用运行程序的测试，包括代码检查、静态结构分析、代码质量度量、文档测试等等，它可以由人工进行，充分发挥人的逻辑思维优势，也可以借助软件工具（Fxcop）自动进行。 动态测试：需要执行代码，通过运行程序找到问题，包括功能确认与接口测试、覆盖率分析、性能分析、内存分析等。 白盒测试中的逻辑覆盖包括语句覆盖、判定覆盖、条件覆盖、判定/条件覆盖、条件组合覆盖和路径覆盖。六种覆盖标准发现错误的能力呈由弱到强的变化： 1.语句覆盖每条语句至少执行一次。 2.判定覆盖每个判定的每个分支至少执行一次。 3.条件覆盖每个判定的每个条件应取到各种可能的值。 4.判定/条件覆盖同时满足判定覆盖条件覆盖。 5.条件组合覆盖每个判定中各条件的每一种组合至少出现一次。 6.路径覆盖使程序中每一条可能的路径至少执行一次。

# 请你说一说当前工作中涉及的测试问题(测试流程和测试性能)

解题思路

在测试性能中，时常会出现脚本回访卡住的问题，原因有以下几种：

1、 runtimesetting 中的continue error没有勾选

2、录制的脚本中存在冗余的代码部分，需要对脚本进行优化，去除冗余的部分（优化脚本） 例如：在用FireFox录制脚本时，脚本中会产生一个叫 ”Url=http://download.cdn.mozilla.net/pub/firefox/releases/43.0.1/update/win32/zh-CN/firefox-43.0.1.complete.mar","Referer=", ENDITEM,”这样的代码（该代码出现的问题不止一处，在查找时一定要注意。），这是因为采用firefox浏览器录制时产生的压缩文件，在脚本回放时卡住的原因正是因为这个（建议：能采用IE录制尽量用IE浏览器） 解决办法：注释掉或者删除掉该段代码即可， 关联问题：在用loadrunner自带对比工具对比脚本后 找到需要关联的动态值。在关联后回放脚本时报错HTTP-status code 417（exception failed）错误时，产生的原因如下： 1、脚本中还存在没有关联或者关联失败的动态值，利用lr自带对比工具仔细对比 2、脚本中的动态值被做了加密策略，仔细查看脚本中动态值的部分，看看动态值是否被做了安全策略（随机生成或者打乱动态值顺序、在动态值中加入了特殊符号），由于在tree-response中的动态值是未被加密的状态，在client向server发送请求时，client的动态值发给服务器，这时服务器的动态值已经被做了参数化，所以服务器不认准client向服务器发送的动态值。 解决办法：去掉动态值的安全策略即可（JVM参数）

# 请你说出几种基本的数据结构

解题思路

常见的基本的数据结构有链表、栈、队列、树（只列出面试常考的基本数据结构） 1、链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。链表由一系列节点组成，这些节点不必在内存中相连。每个节点由数据部分Data和链部分Next，Next指向下一个节点，这样当添加或者删除时，只需要改变相关节点的Next的指向，效率很高。 栈和队列是比较特殊的线性表 栈是限制插入和删除只能在一个位置上进行的表，后进先出 队列只允许在front端进行删除操作，在rear端进行插入操作， 树：树型结构是一类非常重要的非线性数据结构，考察主要以二叉树为主，

# 请你设计一个微信朋友圈点赞的测试用例

解题思路

功能测试： 点赞某条朋友圈，验证是否成功 接口测试： 点赞朋友圈，验证朋友能否收到提示信息 性能测试 点赞朋友圈，是否在规定时间显示结果，是否在规定时间在朋友手机上进行提示 兼容性测试 在不同的终端比如ipad,手机上点赞朋友圈，验证是否成功

# 请你说一下HTTP的报文段是什么样的？

解题思路

1、请求方法 GET：请求获取Request——URL所标识的资源 POST：在Request——URL所标识的资源后附加资源 HEAD：请求获取由Request——URL所标识的资源的响应消息报头 PUT：请求服务器存储一个资源，由Request——URL作为其标识 DELETE：请求服务器删除由Request——URL所标识的资源 TRACE：请求服务器回送收到的请求信息（用于测试和诊断） CONNECT：保留 OPTIONS：请求查询服务器性能

 2、URL URI全名为Uniform Resource Indentifier（统一资源标识），用来唯一的标识一个资源，是一个通用的概念，URI由两个主要的子集URL和URN组成。URL全名为Uniform Resource Locator（统一资源定位），通过描述资源的位置来标识资源。URN全名为Uniform Resource Name（统一资源命名），通过资源的名字来标识资源，与其所处的位置无关，这样即使资源的位置发生变动，其URN也不会变化。

 3、协议版本 格式为HTTP/主版本号.次版本号，常用为：HTTP/1.1 HTTP/1.0

 4、请求头部 Host：接受请求的服务器地址，可以是IP或者是域名 User-Agent：发送请求的应用名称 Connection：指定与连接相关的属性，例如（Keep_Alive，长连接） Accept-Charset：通知服务器端可以发送的编码格式 Accept-Encoding：通知服务器端可以发送的数据压缩格式 Accept-Language：通知服务器端可以发送的语言

 1、协议版本，同请求报文

 2、状态码，100~199表示请求已收到继续处理，200~299表示成功，300~399表示资源重定向，400~499表示客户端请求出错，500~599表示服务器端出错 200：响应成功 302：跳转，重定向 400：客户端有语法错误 403：服务器拒绝提供服务 404：请求资源不存在 500：服务器内部错误

 3、响应头部 Server：服务器应用软件的名称和版本 Content-Type：响应正文的类型 Content-Length：响应正文的长度 Content-Charset：响应正文所使用的编码 Content-Encoding：响应正文使用的数据压缩格式 Content-Language：响应正文使用的语言

# 请你说一说http请求报文

解题思路

1、请求方法 GET：请求获取Request——URL所标识的资源 POST：在Request——URL所标识的资源后附加资源 HEAD：请求获取由Request——URL所标识的资源的响应消息报头 PUT：请求服务器存储一个资源，由Request——URL作为其标识 DELETE：请求服务器删除由Request——URL所标识的资源 TRACE：请求服务器回送收到的请求信息（用于测试和诊断） CONNECT：保留 OPTIONS：请求查询服务器性能

 2、URL URI全名为Uniform Resource Indentifier（统一资源标识），用来唯一的标识一个资源，是一个通用的概念，URI由两个主要的子集URL和URN组成。URL全名为Uniform Resource Locator（统一资源定位），通过描述资源的位置来标识资源。URN全名为Uniform Resource Name（统一资源命名），通过资源的名字来标识资源，与其所处的位置无关，这样即使资源的位置发生变动，其URN也不会变化。

 3、协议版本 格式为HTTP/主版本号.次版本号，常用为：HTTP/1.1 HTTP/1.0

 4、请求头部 Host：接受请求的服务器地址，可以是IP或者是域名 User-Agent：发送请求的应用名称 Connection：指定与连接相关的属性，例如（Keep_Alive，长连接） Accept-Charset：通知服务器端可以发送的编码格式 Accept-Encoding：通知服务器端可以发送的数据压缩格式 Accept-Language：通知服务器端可以发送的语言

# 请你回答一下TCP三次握手，以及为什么不是两次

解题思路

第一次握手：建立连接时，客户端发送syn包（syn=j）到服务器，并进入SYN_SENT状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）。 第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态； 第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。 为什么不是两次： 在服务端对客户端的请求进行回应(第二次握手)后，就会理所当然的认为连接已建立，而如果客户端并没有收到服务端的回应呢？此时，客户端仍认为连接未建立，服务端会对已建立的连接保存必要的资源，如果大量的这种情况，服务端会崩溃。

# 请问你怎么看待软件测试的潜力和挑战

解题思路

软件测试是正在快速发展，充满挑战的领域。尽管现在许多自动化测试软件的出现使得传统手工测试的方式被代替，但自动化测试工具的开发、安全测试、测试建模、精准测试、性能测试、可靠性测试等专项测试中仍然需要大量具有专业技能与专业素养的测试人员，并且随着云计算、物联网、大数据的发展，传统的测试技术可能不再适用，测试人员也因此面临着挑战，需要深入了解新场景并针对不同场景尝试新的测试方法，同时敏捷测试、Devops的出现也显示了软件测试的潜力。

# 请你说一下app性能测试的指标

解题思路

1、内存：内存消耗测试节点的设计目标是为了让应用不占用过多的系统资源，且及时释放内存，保障整个系统的稳定性。当然关于内存测试，在这里我们需要引入几个概念：空闲状态、中等规格、满规格。 空闲状态指打开应用后，点击home键让应用后台运行，此时应用处于的状态叫做空闲；中等规格和满规格指的是对应用的操作时间的间隔长短不一，中等规格时间较长，满规格时间较短。 内存测试中存在很多测试子项，清单如下：

●空闲状态下的应用内存消耗；

●中等规格状态下的应用内存消耗；

●满规格状态下的应用内存消耗；

●应用内存峰值；

●应用内存泄露；

●应用是否常驻内存；

●压力测试后的内存使用。

2、CPU： 使用Android提供的view plncopy在CODE上查看代码片派生到我的代码片 adbshell dumpsys CPUinfo |grep packagename >/address/CPU.txt来获取； 使用top命令view plncopy在CODE上查看代码片派生到我的代码片 adbshell top |grep packagename>/address/CPU.txt来获取。

3、流量： 网络流量测试是针对大部分应用而言的，可能还有部分应用会关注网速、弱网之类的测试。 流量测试包括以下测试项： 应用首次启动流量提示； 应用后台连续运行2小时的流量值； 应用高负荷运行的流量峰值。

4、电量：

    ●测试手机安装目标APK前后待机功耗无明显差异；

    ●常见使用场景中能够正常进入待机，待机电流在正常范围内；

    ●长时间连续使用应用无异常耗电现象。

5、启动速度： 第一类：首次启动--应用首次启动所花费的时间； 第二类：非首次启动--应用非首次启动所花费的时间； 第三类：应用界面切换--应用界面内切换所花费的时间。

6、滑动速度、界面切换速度

7、与服务器交互的网络速度

# 请你根据微信登录界面设计测试用例

解题思路

一、功能测试

 1.输入正确的用户名和密码，点击提交按钮，验证是否能正确登录。

 2.输入错误的用户名或者密码,验证登录会失败，并且提示相应的错误信息。

 3.登录成功后能否能否跳转到正确的页面

 4.检查能否选择不同登录方式进行登录，如使用手机号登录、使用微信号登录或扫码登录。

 5.记住用户名的功能

 6.登陆失败后，不能记录密码的功能

 7.密码是否非明文显示显示，使用星号圆点等符号代替。

 8.有验证码时，还要考虑文字是否扭曲过度导致辨认难度大，考虑颜色、刷新或换一个按钮是否好用

 9.登录页面中的注册、忘记密码，登出用另一帐号登陆等链接是否正确

 10.输入密码的时候，大写键盘开启的时候要有提示信息。

 11.什么都不输入，点击提交按钮，检查提示信息。

 二、界面测试

 1.布局是否合理，testbox和按钮是否整齐。

 2.testbox和按钮的长度，高度是否复合要求。

3. 界面的设计风格是否与UI的设计风格统一。
4. 界面中的文字简洁易懂，没有错别字。

 三、性能测试

 1.打开登录页面，需要的时间是否在需求要求的时间内。

 2.输入正确的用户名和密码后，检查登录成功跳转到新页面的时间是否在需求要求的时间内。

 3.模拟大量用户同时登陆，检查一定压力下能否正常登陆跳转。

 四、安全性测试

 1.登录成功后生成的Cookie，是否是httponly (否则容易被脚本盗取)。

 2.用户名和密码是否通过加密的方式，发送给Web服务器。

 3.用户名和密码的验证，应该是用服务器端验证， 而不能单单是在客户端用javascript 验证。

 4.用户名和密码的输入框，应该屏蔽SQL注入攻击。

 5.用户名和密码的的输入框，应该禁止输入脚本 （防止XSS攻击）。

 6.防止暴力破解，检测是否有错误登陆的次数限制。

7. 是否支持多用户在同一机器上登录。
8. 同一用户能否在多台机器上登录。

 五、兼容性测试

 1.不同移动平台或PC环境下下能否显示正常且功能正常

 2.同种平台下不同微信版本下能否显示正常且功能正常。

 3.不同的分辨率下显示是否正常。

 七、本地化测试

1. 不同语言环境下，页面的显示是否正确。

# 请问你有没有做过压力测试

解题思路

在软件工程中，压力测试是对系统不断施加压力的测试，是通过确定一个系统的瓶颈或者不能接收的性能点，来获得系统能提供的最大服务级别的测试。例如测试一个Web 站点在大量的负荷下，何时系考察公司：网易 统的响应会退化或失败。网络游戏中也常用到这个词汇。

# 请你分别介绍一下单元测试、集成测试、系统测试、验收测试、回归测试

解题思路

1、单元测试：完成最小的软件设计单元（模块）的验证工作，目标是确保模块被正确的编码，使用过程设计描述作为指南，对重要的控制路径进行测试以发现模块内的错误，通常情况下是白盒的，对代码风格和规则、程序设计和结构、业务逻辑等进行静态测试，及早的发现和解决不易显现的错误。

2、集成测试：通过测试发现与模块接口有关的问题。目标是把通过了单元测试的模块拿来，构造一个在设计中所描述的程序结构，应当避免一次性的集成（除非软件规模很小），而采用增量集成。 自顶向下集成：模块集成的顺序是首先集成主模块，然后按照控制层次结构向下进行集成，隶属于主模块的模块按照深度优先或广度优先的方式集成到整个结构中去。 自底向上集成：从原子模块开始来进行构造和测试，因为模块是自底向上集成的，进行时要求所有隶属于某个给顶层次的模块总是存在的，也不再有使用稳定测试桩的必要。

3、系统测试：是基于系统整体需求说明书的黑盒类测试，应覆盖系统所有联合的部件。系统测试是针对整个产品系统进行的测试，目的是验证系统是否满足了需求规格的定义，找出与需求规格不相符合或与之矛盾的地方。系统测试的对象不仅仅包括需要测试的产品系统的软件，还要包含软件所依赖的硬件、外设甚至包括某些数据、某些支持软件及其接口等。因此，必须将系统中的软件与各种依赖的资源结合起来，在系统实际运行环境下来进行测试。

4、回归测试：回归测试是指在发生修改之后重新测试先前的测试用例以保证修改的正确性。理论上，软件产生新版本，都需要进行回归测试，验证以前发现和修复的错误是否在新软件版本上再次出现。根据修复好了的缺陷再重新进行测试。回归测试的目的在于验证以前出现过但已经修复好的缺陷不再重新出现。一般指对某已知修正的缺陷再次围绕它原来出现时的步骤重新测试。

5、验收测试：验收测试是指系统开发生命周期方法论的一个阶段，这时相关的用户或独立测试人员根据测试计划和结果对系统进行测试和接收。它让系统用户决定是否接收系统。它是一项确定产品是否能够满足合同或用户所规定需求的测试。验收测试包括Alpha测试和Beta测试。 Alpha测试：是由用户在开发者的场所来进行的，在一个受控的环境中进行。 Beta测试：由软件的最终用户在一个或多个用户场所来进行的，开发者通常不在现场，用户记录测试中遇到的问题并报告给开发者，开发者对系统进行最后的修改，并开始准备发布最终的软件。

# 你觉得测试和开发需要怎么结合才能使软件的质量得到更好的保障

解题思路

测试和开发应该按照W模型的方式进行结合，测试和开发同步进行，能够尽早发现软件缺陷，降低软件开发的成本。 在V模型中，测试过程被加在开发过程的后半部分，单元测试所检测代码的开发是否符合详细设计的要求。集成测试所检测此前测试过的各组成部分是否能完好地结合到一起。系统测试所检测已集成在一起的产品是否符合系统规格说明书的要求。而验收测试则检测产品是否符合最终用户的需求。V模型的缺陷在于仅仅把测试过程作为在需求分析、系统设计及编码之后的一个阶段，忽视了测试对需求分析、系统设计的验证，因此需求阶段的缺陷很可能一直到后期的验收测试才被发现，此时进行弥补将耗费大量人力物力资源。 相对于V模型，W模型增加了软件各开发阶段中应同步进行的验证和确认活动。W模型由两个V字型模型组成，分别代表测试与开发过程，图中明确 表示出了测试与开发的并行关系。 W模型强调：测试伴随着整个软件开发周期，而且测试的对象不仅仅是程序，需求、设计等同样要测试，也就是说，测试与开发是同步进行的。W模型有利于尽早地全面的发现问题。例如，需求分析完成后，测试人员就应该参与到对需求的验证和确认活动中，以尽早地找出缺陷所在。同时，对需求的测试也有利于及时了解项目难度和 测试风险，及早制定应对措施，这将显著减少总体测试时间，加快项目进度。 W模型中测试的活动与软件开发同步进行，测试的对象不仅仅是程序，还包括需求和设计，因此能够尽早发现软件缺陷，降低软件开发的成本。

# 你觉得自动化测试有什么意义，都需要做些什么

解题思路

自动化测试的意义在于

    1、可以对程序的新版本自动执行回归测试

    2、可以执行手工测试困难或者不可能实现的测试，如压力测试，并发测试，

    3、能够更好的利用资源，节省时间和人力 执行自动化测试之前首先判断这个项目是不是和推广自动化测试，然后对项目做需求分析，指定测试计划，搭建自动化测试框架，设计测试用例，执行测试，评估

# 你写的测试程序是怎么样的，你写过前端、后端程序吗？

解题思路

开发测试驱动程序一般分为4步：

1，指出需要的新特性。可以记录下来，然后为其编写一个测试。

2，编写特性的概要代码，这样程序就可以运行而没有任何语法等方面的错误，但是测试会失败。看到测试失败是很重要的，这样就能确定测试可以失败。如果测试代码中出现了错误，那么就有可能出现任何情况，测试都会成功，这样等于没测试任何东西。再强调一遍：在试图测试成功之前，先要看到它失败。

3，为特性的概要编写虚设代码，能满足测试要求就行。不用准确的实现功能，只要保证测试可以通过即可。这样一来就可以保证在开发的时候总是通过测试了，（除了第一次测试的时候）甚至在最初实现功能时亦是如此。

4，现在重写（或者重构）代码，这样它就会做自己应该做的事，从而保证测试一直成功。 在编码完成时，应该保证代码处于健康状态--不要遗留下任何测试失败。 写过前段程序。

# 请问你遇到过哪些印象深刻的bug，接口测试出现bug的原因有哪些？

解题思路

面试官询问遇到过哪些印象深刻的bug，其实它并不关心你描述的这个bug是否真的有价值，或有多曲折离奇？他只是：了解你平时工作中的测试能力 所以，这就要求的你平时工作中遇到bug时试着自己去定位，定位bug的过程远比你的单纯的执行测试用例有“价值”（自我技能提高的价值），在定位bug的过程中你需要掌握和运用更多知识。 另外，建议你平时养成总结的好习惯，发现的bug，开发解决了，最好问问他原因以及解决的方法，这样再遇到类似问题时，自己也可以试着定位解决。遇到难解决的bug，也可以把最终的解决过程记录下来。（这不是就有素材了） 所以，建议你平时可以主动要求去分享一些自己工作中用到或学习的技术。或者多去参加集体活动，加强自己的表达能力。From:虫师 接口测试常见的bug有以下几个: 特殊值处理不当导致程序异常退出或者崩溃 类型边界溢出，导致数据独处和写入不一致 取值边界外未返回正确的错误信息 权限未处理，可以访问其他用户的信息 逻辑校验不完善，可以利用漏洞获取非正当利益 状态处理不当，导致逻辑出现错误 数组类型item个数为0或者item重复时程序异常退出

# 请问你在项目中关于功能测试和接口测试是怎么做的

解题思路

功能测试： 首先制定测试计划，然后进行测试设计，将在测试计划阶段指定的测试活动分解，进而细化，为若干个可执行程序的子测试过程，然后执行测试，按照测试计划使用测试用例对待测项目进行逐一的，详细的排查分析评估，最后对测试结果进行统计和分析， 接口测试： 什么是接口（API） API全称Application Programming Interface，这里面我们其实不用去关注AP，只需要I上就可以。一个API就是一个Interface。我们无时不刻不在使用interfaces。我们乘坐电梯里面的按钮是一个interface。我们开车一个踩油门它也是一个interface。我们计算机操作系统也是有很多的接口。(这是目前个人找到比较好理解的一段解释) 接口就是一个位于复杂系统之上并且能简化你的任务，它就像一个中间人让你不需要了解详细的所有细节。那我们今天要讲的Web API就是这么一类东西。像谷歌搜索系统，它提供了搜索接口，简化了你的搜索任务。再像用户登录页面，我们只需要调用我们的登录接口，我们就可以达到登录系统的目的。 现在市面上有非常多种风格的Web API，目前最流行的是也容易访问的一种风格是REST或者叫RESTful 风格的API。从现在开始，以下我提到的所有API都是指RESTful风格的API。 什么是接口测试和为什么要做接口测试 接口测试是测试系统组件间接口的一种测试。接口测试主要用于检测外部系统与系统之间以及内部各个子系统之间的交互点。测试的重点是要检查数据的交换，传递和控制管理过程，以及系统间的相互逻辑依赖关系等。 现在很多系统前后端架构是分离的，从安全层面来说，只依赖前端进行限制已经完全不能满足系统的安全要求（绕过前端太容易了），需要后端同样进行控制，在这种情况下就需要从接口层面进行验证。 如今系统越来越复杂，传统的靠前端测试已经大大降低了效率，而且现在我们都推崇测试前移，希望测试能更早的介入测试，那接口测试就是一种及早介入的方式。例如传统测试，你是不是得等前后端都完成你才能进行测试，才能进行自动化代码编写。而如果是接口测试，只需要前后端定义好接口，那这时自动化就可以介入编写接口自动化测试代码，手工测试只需要后端代码完成就可以介入测试后端逻辑而不用等待前端工作完成。 接口测试的策略 接口测试也是属于功能测试，所以跟我们以往的功能测试流程并没有太大区别，测试流程依旧是：1.测试接口文档（需求文档） 2.根据接口文档编写测试用例（用例编写完全可以按照以往规则来编写，例如等价类划分，边界值等设计方法）3. 执行测试，查看不同的参数请求，接口的返回的数据是否达到预期。

# 请问你有用过什么测试工具吗，用过哪些？

解题思路

自动化测试工具用过selenium和appium 性能测试工具有用过Jmeter

# 请你回答一下性能测试有哪些指标，对一个登录功能做性能测试，有哪些指标，怎么测出可同时处理的最大请求数量

解题思路

性能测试常用指标： 从外部看，主要有

1、吞吐量：每秒钟系统能够处理的请求数，任务数

2、响应时间：服务处理一个请求或一个任务的耗时

3、错误率：一批请求中结果出错的请求所占比例 从服务器的角度看，性能测试关注CPU，内存，服务器负载，网络，磁盘ＩＯ 对登录功能做性能测试 单用户登陆的响应界面是否符合预期 单用户登陆时后台请求数量是否过多 高并发场景下用户登录的响应界面是否符合预期 高并发场景下服务端的监控指标是否符合预期 高集合点并发场景下是否存在资源死锁和不合理的资源等待 长时间大量用户连续登录和登出，服务器端是否存在内存泄漏 怎么测出可同时处理的最大请求数量 可以采用性能测试工具(WeTest服务器性能)，该工具是腾讯wetest团队出品，使用起来很简单方便，但测试功能相当强大，能提供10w+以上的并发量，定位性能拐点，测出服务器模型最大并发

# 请说一下手动测试与自动化测试的优缺点

解题思路

手工测试缺点：

 1、重复的手工回归测试，代价昂贵、容易出错。

 2、依赖于软件测试人员的能力。 手工测试优点：

    1、测试人员具有经验和对错误的猜测能力。

    2、测试人员具有审美能力和心理体验。

    3、测试人员具有是非判断和逻辑推理能力。 自动化测试的优点：

 1、对程序的回归测试更方便。这可能是自动化测试最主要的任务，特别是在程序修改比较频繁时，效果是非常明显的。由于回归测试的动作和用例是完全设计好的，测试期望的结果也是完全可以预料的，将回归测试自动运行，可以极大提高测试效率，缩短回归测试时间。

 2、可以运行更多更繁琐的测试。自动化的一个明显的好处是可以在较少的时间内运行更多的测试。

 3、可以执行一些手工测试困难或不可能进行的测试。比如，对于大量用户的测试，不可能同时让足够多的测试人员同时进行测试，但是却可以通过自动化测试模拟同时有许多用户，从而达到测试的目的。

 4、更好地利用资源。将繁琐的任务自动化，可以提高准确性和测试人员的积极性，将测试技术人员解脱出来投入更多精力设计更好的测试用例。有些测试不适合于自动测试，仅适合于手工测试，将可自动测试的测试自动化后，可以让测试人员专注于手工测试部分，提高手工测试的效率。

 5、测试具有一致性和可重复性。由于测试是自动执行的，每次测试的结果和执行的内容的一致性是可以得到保障的，从而达到测试的可重复的效果。

 6、测试的复用性。由于自动测试通常采用脚本技术，这样就有可能只需要做少量的甚至不做修改，实现在不同的测试过程中使用相同的用例。 7、增加软件信任度。由于测试是自动执行的，所以不存在执行过程中的疏忽和错误，完全取决于测试的设计质量。一旦软件通过了强有力的自动测试后，软件的信任度自然会增加。 自动化测试的缺点：

    1、不能取代手工测试

    2、手工测试比自动测试发现的缺陷更多

    3、对测试质量的依赖性极大

    4、测试自动化不能提高有效性

    5、测试自动化可能会制约软件开发。由于自动测试比手动测试更脆弱，所以维护会受到限制，从而制约软件的开发。

    6、工具本身并无想像力

# 请问你觉得测试项目具体工作是什么？

解题思路

搭建测试环境 撰写测试用例 执行测试用例 写测试计划，测试报告 测试，并提交BUG表单 跟踪bug修改情况 执行自动化测试，编写脚本，执行，分析，报告 进行性能测试，压力测试等其他测试，执行，分析，调优，报告

# 请你说一说测试工程师的必备技能

解题思路

需要的知识： • 软件测试基础理论知识，如黑盒测试、白盒测试等； • 编程语言基础，如C/C++、java、python等； • 自动化测试工具，如Selenium、Appium、Robotium等； • 计算机基础知识，如数据库、Linux、计算机网络等； • 测试框架，如JUnit等。 需要具备的能力： • 业务分析能力，分析整体业务流程、分析被测业务数据、分析被测系统架构、分析被测业务模块、分析测试所需资源、分析测试完成目标； • 缺陷洞察能力，一般缺陷的发现能力、隐性问题的发现能力、发现连带问题的能力、发现问题隐患的能力、尽早发现问题的能力、发现问题根源的能力； • 团队协作能力，合理进行人员分工、协助组员解决问题、配合完成测试任务、配合开发重现缺陷、督促项目整体进度、出现问题勇于承担； • 专业技术能力，掌握测试基础知识、掌握计算机知识、熟练运用测试工具； • 逻辑思考能力，判断逻辑的正确性、对可行性逻辑分析、站在客观角度思考； • 问题解决能力，技术上的问题、工作中的问题、沟通问题； • 沟通表达能力，和技术人员、产品人员、上下级的沟通； • 宏观把控能力，有效控制测试时间、有效控制测试成本、有效制定测试计划、有效进行风险评估、有效控制测试方向。

# 请问你怎么看待测试，知道哪些测试的类型，有用过哪些测试方法？

解题思路

测试是软件开发中不可或缺的一环，测试通过经济，高效的方法，捕捉软件中的错误，从而达到保重软件内在质量的目的。 测试分为功能测试和非功能测试，非功能测试又可以分为性能测试、压力测试、容量测试、健壮性测试、安全性测试、可靠性测试、恢复性测试、备份测试、协议测试、兼容性测试、可用性测试、配置测试、GUI测试。 测试方法用过等价划分法、边值分析法、错误推测法、因果图法。

# 如何测试登陆界面

解题思路

一、功能测试

 1.输入正确的用户名和密码，点击提交按钮，验证是否能正确登录。

 2.输入错误的用户名或者密码,验证登录会失败，并且提示相应的错误信息。

 3.登录成功后能否能否跳转到正确的页面

 4.用户名和密码，如果太短或者太长，应该怎么处理

 5.用户名和密码，中有特殊字符（比如空格），和其他非英文的情况

 6.记住用户名的功能

 7.登陆失败后，不能记录密码的功能

 8.用户名和密码前后有空格的处理

 9.密码是否非明文显示显示，使用星号圆点等符号代替。

 10.牵扯到验证码的，还要考虑文字是否扭曲过度导致辨认难度大，考虑颜色（色盲使 用者），刷新或换一个按钮是否好用

 11.登录页面中的注册、忘记密码，登出用另一帐号登陆等链接是否正确

 12.输入密码的时候，大写键盘开启的时候要有提示信息。

 13.什么都不输入，点击提交按钮，检查提示信息。

 二、界面测试

 1.布局是否合理，testbox和按钮是否整齐。

 2.testbox和按钮的长度，高度是否复合要求。

3. 界面的设计风格是否与UI的设计风格统一。
4. 界面中的文字简洁易懂，没有错别字。

 三、性能测试

 1.打开登录页面，需要的时间是否在需求要求的时间内。

 2.输入正确的用户名和密码后，检查登录成功跳转到新页面的时间是否在需求要求的时间内。

 3.模拟大量用户同时登陆，检查一定压力下能否正常登陆跳转。

 四、安全性测试

 1.登录成功后生成的Cookie，是否是httponly (否则容易被脚本盗取)。

 2.用户名和密码是否通过加密的方式，发送给Web服务器。

 3.用户名和密码的验证，应该是用服务器端验证， 而不能单单是在客户端用javascript 验证。

 4.用户名和密码的输入框，应该屏蔽SQL注入攻击。

 5.用户名和密码的的输入框，应该禁止输入脚本 （防止XSS攻击）。

 6.防止暴力破解，检测是否有错误登陆的次数限制。

 \7. 是否支持多用户在同一机器上登录。

 \8. 同一用户能否在多台机器上登录。

 五、可用性测试

 \1. 是否可以全用键盘操作，是否有快捷键。

 \2. 输入用户名，密码后按回车，是否可以登陆。

 \3. 输入框能否可以以Tab键切换。

 六、兼容性测试

 1.不同浏览器下能否显示正常且功能正常（IE,6,7,8,9, Firefox, Chrome, Safari,等）。

 2.同种浏览器不同版本下能否显示正常且功能正常。

 2.不同的平台是否能正常工作，比如Windows, Mac。

 3.移动设备上是否正常工作，比如Iphone, Andriod。

 4.不同的分辨率下显示是否正常。

 七、本地化测试

 \1. 不同语言环境下，页面的显示是否正确。

# 请你说一下多态

解题思路

什么是多态？ 多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量倒底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。因为在程序运行时才确定具体的类，这样，不用修改源程序代码，就可以让引用变量绑定到各种不同的类实现上，从而导致该引用调用的具体方法随之改变，即不修改程序代码就可以改变程序运行时所绑定的具体代码，让程序可以选择多个运行状态，这就是多态性。 Java实现多态有三个必要条件：继承、重写、向上转型。 继承：在多态中必须存在有继承关系的子类和父类。 重写：子类对父类中某些方法进行重新定义，在调用这些方法时就会调用子类的方法。 向上转型：在多态中需要将子类的引用赋给父类对象，只有这样该引用才能够具备技能调用父类的方法和子类的方法。 Java中有两种形式可以实现多态，继承和接口： 基于继承的实现机制主要表现在父类和继承该父类的一个或多个子类对某些方法的重写，多个子类对同一方法的重写可以表现出不同的行为。 基于接口的多态中，指向接口的引用必须是指定这实现了该接口的一个类的实例程序，在运行时，根据对象引用的实际类型来执行对应的方法。

# 请你说一下死锁的原因，以及如何打破，如何查看死锁进程状态

解题思路

1、死锁是指在一组进程中的各个进程均占有不会释放的资源，但因互相申请被其他进程所站用不会释放的资源而处于的一种永久等待状态。死锁的四个必要条件： • 互斥条件(Mutual exclusion)：资源不能被共享，只能由一个进程使用。 • 请求与保持条件(Hold and wt)：已经得到资源的进程可以再次申请新的资源。 • 非剥夺条件(No pre-emption)：已经分配的资源不能从相应的进程中被强制地剥夺。 • 循环等待条件(Circular wt)：系统中若干进程组成环路，该环路中每个进程都在等待相邻进程正占用的资源。 java中产生死锁可能性的最根本原因是：1）是多个线程涉及到多个锁，这些锁存在着交叉，所以可能会导致了一个锁依赖的闭环；2）默认的锁申请操作是阻塞的。 如，线程在获得一个锁L1的情况下再去申请另外一个锁L2，也就是锁L1想要包含了锁L2，在获得了锁L1，并且没有释放锁L1的情况下，又去申请获得锁L2，这个是产生死锁的最根本原因。 2、避免死锁： • 方案一：破坏死锁的循环等待条件。 • 方法二：破坏死锁的请求与保持条件，使用lock的特性，为获取锁操作设置超时时间。这样不会死锁（至少不会无尽的死锁） • 方法三：设置一个条件遍历与一个锁关联。该方法只用一把锁，没有chopstick类，将竞争从对筷子的争夺转换成了对状态的判断。仅当左右邻座都没有进餐时才可以进餐。提升了并发度。 3、linux中查看死锁进程状态 使用pstack 和 gdb 工具对死锁程序进行分析 pstack 进程号 查看各个线程的堆栈信息 当进程吊死的时候，多次使用，死锁的线程将一直处于等锁的状态，确定某些线程一直没有变化，一直处于等锁的状态。那么这些线程很可能是死锁了。如果怀疑哪些线程发生死锁了，可以采用gdb 进一步attach线程并进行分析。 执行命令gdb attach 进程号，进入gdb调试终端 运行：(gdb) info thread

# 请你说一下为什么tcp可靠，哪些方法保证可靠

解题思路

[1] 确认和重传机制 建立连接时三次握手同步双方的“序列号 + 确认号 + 窗口大小信息”，是确认重传、流控的基础 传输过程中，如果Checksum校验失败、丢包或延时，发送端重传。

 [2] 数据排序 TCP有专门的序列号SN字段，可提供数据re-order

 [3] 流量控制 滑动窗口和计时器的使用。TCP窗口中会指明双方能够发送接收的最大数据量，发送方通过维持一个发送滑动窗口来确保不会发生由于发送方报文发送太快接收方无法及时处理的问题。

 [4] 拥塞控制 TCP的拥塞控制由4个核心算法组成： “慢启动”（Slow Start） “拥塞避免”（Congestion avoidance） “快速重传 ”（Fast Retransmit） “快速恢复”（Fast Recovery）

# 请你进行一下弱网模拟

解题思路

配置参数解析： bandwidth —— 带宽，即上行、下行数据传输速度 utilisation —— 带宽可用率，大部分modern是100% round-trip latency —— 第一个请求的时延，单位是ms。 MTU —— 最大传输单元，即TCP包的最大size，可以更真实模拟TCP层，每次传输的分包情况。 Releability —— 指连接的可靠性。这里指的是10kb的可靠率。用于模拟网络不稳定。 Stability —— 连接稳定性，也会影响带宽可用性。用于模拟移动网络，移动网络连接一般不可靠。 使用chrome的webview调试工具，缺点是只适用于web页面的弱网模拟。

# 请你说一下垃圾回收机制

解题思路

垃圾回收(Garbage Collection)是Java虚拟机(JVM)垃圾回收器提供的一种用于在空闲时间不定时回收无任何对象引用的对象占据的内存空间的一种机制。 引用：如果Reference类型的数据中存储的数值代表的是另外一块内存的起始地址，就称这块内存代表着一个引用。 （1）强引用（Strong Reference）：如“Object obj = new Object（）”，这类引用是Java程序中最普遍的。只要强引用还存在，垃圾收集器就永远不会回收掉被引用的对象。

 （2）软引用（Soft Reference）：它用来描述一些可能还有用，但并非必须的对象。在系统内存不够用时，这类引用关联的对象将被垃圾收集器回收。JDK1.2之后提供了SoftReference类来实现软引用。

 （3）弱引用（Weak Reference）：它也是用来描述非须对象的，但它的强度比软引用更弱些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。在JDK1.2之后，提供了WeakReference类来实现弱引用。

 （4）虚引用（Phantom Reference）：最弱的一种引用关系，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的是希望能在这个对象被收集器回收时收到一个系统通知。JDK1.2之后提供了PhantomReference类来实现虚引用。 垃圾：无任何对象引用的对象。 判断对象是否是垃圾的算法： 引用计数算法（Reference Counting Collector）、根搜索算法（Tracing Collector）： 回收：清理“垃圾”占用的内存空间而非对象本身。 Tracing算法（Tracing Collector） 标记—清除算法：分为“标记”和“清除”两个阶段：首先标记出所需回收的对象，在标记完成后统一回收掉所有被标记的对象，它的标记过程其实就是前面的根搜索算法中判定垃圾对象的标记过程。 Compacting算法（Compacting Collector）标记—整理算法：标记的过程与标记—清除算法中的标记过程一样，但对标记后出的垃圾对象的处理情况有所不同，它不是直接对可回收对象进行清理，而是让所有的对象都向一端移动，然后直接清理掉端边界以外的内存。在基于Compacting算法的收集器的实现中，一般增加句柄和句柄表。 Copying算法（Copying Collector）：将内存按容量分为大小相等的两块，每次只使用其中的一块（对象面），当这一块的内存用完了，就将还存活着的对象复制到另外一块内存上面（空闲面），然后再把已使用过的内存空间一次清理掉。 Adaptive算法（Adaptive Collector）：监控当前堆的使用情况，并将选择适当算法的垃圾收集器。 发生地点：一般发生在堆内存中，因为大部分的对象都储存在堆内存中。 （堆内存为了配合垃圾回收有什么不同区域划分，各区域有什么不同？） Java的堆内存基于Generation算法（Generational Collector）划分为新生代、年老代和持久代。新生代又被进一步划分为Eden和Survivor区，最后Survivor由FromSpace（Survivor0）和ToSpace（Survivor1）组成。所有通过new创建的对象的内存都在堆中分配，其大小可以通过-Xmx和-Xms来控制。分代收集基于这样一个事实：不同的对象的生命周期是不一样的。因此，可以将不同生命周期的对象分代，不同的代采取不同的回收算法进行垃圾回收（GC），以便提高回收效率。 按执行机制划分Java有四种类型的垃圾回收器：

 （1）串行垃圾回收器（Serial Garbage Collector）

 （2）并行垃圾回收器（Parallel Garbage Collector）

 （3）并发标记扫描垃圾回收器（CMS Garbage Collector）

 （4）G1垃圾回收器（G1 Garbage Collector） 发生时间：程序空闲时间不定时回收。

# 请问多线程是什么？

解题思路

最开始，线程只是用于分配单个处理器的处理时间的一种工具。但假如操作系统本身支持多个处理器，那么每个线程都可分配给一个不同的处理器，真正进入“并行运算”状态。从程序设计语言的角度看，多线程操作最有价值的特性之一就是程序员不必关心到底使用了多少个处理器。程序在逻辑意义上被分割为数个线程;假如机器本身安装了多个处理器，那么程序会运行得更快，毋需作出任何特殊的调校。根据前面的论述，大家可能感觉线程处理非常简单。但必须注意一个问题：共享资源!如果有多个线程同时运行，而且它们试图访问相同的资源，就会遇到一个问题。举个例子来说，两个线程不能将信息同时发送给一台打印机。为解决这个问题，对那些可共享的资源来说(比如打印机)，它们在使用期间必须进入锁定状态。所以一个线程可将资源锁定，在完成了它的任务后，再解开(释放)这个锁，使其他线程可以接着使用同样的资源。 多线程是为了同步完成多项任务，不是为了提高运行效率，而是为了提高资源使用效率来提高系统的效率。线程是在同一时间需要完成多项任务的时候实现的。 一个采用了多线程技术的应用程序可以更好地利用系统资源。其主要优势在于充分利用了CPU的空闲时间片，可以用尽可能少的时间来对用户的要求做出响应，使得进程的整体运行效率得到较大提高，同时增强了应用程序的灵活性。更为重要的是，由于同一进程的所有线程是共享同一内存，所以不需要特殊的数据传送机制，不需要建立共享存储区或共享文件，从而使得不同任务之间的协调操作与运行、数据的交互、资源的分配等问题更加易于解决。

# 进程线程优缺点和应用场景

多进程优点
①编程相对容易；通常不需要考虑锁和同步资源的问题。
②更强的容错性：比起多线程的一个好处是一个进程崩溃了不会影响其他进程。
③有内核保证的隔离：数据和错误隔离。 对于使用如C/C++这些语言编写的本地代码，错误隔离是非常有用的：采用多进程架构的程序一般可以做到一定程度的自恢复；（master守护进程监控所有worker进程，发现进程挂掉后将其重启）。

多线程的优点：
①创建速度快，方便高效的数据共享
共享数据：多线程间可以共享同一虚拟地址空间；多进程间的数据共享就需要用到共享内存、信号量等IPC技术。
②较轻的上下文切换开销 - 不用切换地址空间，不用更改寄存器，不用刷新TLB。
③提供非均质的服务。如果全都是计算任务，但每个任务的耗时不都为1s，而是1ms-1s之间波动；这样，多线程相比多进程的优势就体现出来，它能有效降低“简单任务被复杂任务压住”的概率。

应用场景
多进程应用场景
1.nginx主流的工作模式是多进程模式（也支持多线程模型）
2.几乎所有的web server服务器服务都有多进程的，至少有一个守护进程配合一个worker进程，例如apached,httpd等等以d结尾的进程包括init.d本身就是0级总进程，所有你认知的进程都是它的子进程；
3.chrome浏览器也是多进程方式。 （原因：①可能存在一些网页不符合编程规范，容易崩溃，采用多进程一个网页崩溃不会影响其他网页；而采用多线程会。②网页之间互相隔离，保证安全，不必担心某个网页中的恶意代码会取得存放在其他网页中的敏感信息。）
4.redis也可以归类到“多进程单线程”模型（平时工作是单个进程，涉及到耗时操作如持久化或aof重写时会用到多个进程）

多线程应用场景
线程间有数据共享，并且数据是需要修改的（不同任务间需要大量共享数据或频繁通信时）。
提供非均质的服务（有优先级任务处理）事件响应有优先级。
单任务并行计算，在非CPU Bound的场景下提高响应速度，降低时延。
与人有IO交互的应用，良好的用户体验（键盘鼠标的输入，立刻响应）
案例：
桌面软件，响应用户输入的是一个线程，后台程序处理是另外的线程；

# 请你说一说有哪几种垃圾回收算法

解题思路

Tracing算法（Tracing Collector） 标记—清除算法：分为“标记”和“清除”两个阶段：首先标记出所需回收的对象，在标记完成后统一回收掉所有被标记的对象，它的标记过程其实就是前面的根搜索算法中判定垃圾对象的标记过程。 Compacting算法（Compacting Collector）标记—整理算法：标记的过程与标记—清除算法中的标记过程一样，但对标记后出的垃圾对象的处理情况有所不同，它不是直接对可回收对象进行清理，而是让所有的对象都向一端移动，然后直接清理掉端边界以外的内存。在基于Compacting算法的收集器的实现中，一般增加句柄和句柄表。 Copying算法（Copying Collector）：将内存按容量分为大小相等的两块，每次只使用其中的一块（对象面），当这一块的内存用完了，就将还存活着的对象复制到另外一块内存上面（空闲面），然后再把已使用过的内存空间一次清理掉。 Adaptive算法（Adaptive Collector）：监控当前堆的使用情况，并将选择适当算法的垃圾收集器。

# 请你说一说垃圾收集机制

解题思路

垃圾回收(Garbage Collection)是Java虚拟机(JVM)垃圾回收器提供的一种用于在空闲时间不定时回收无任何对象引用的对象占据的内存空间的一种机制。 引用：如果Reference类型的数据中存储的数值代表的是另外一块内存的起始地址，就称这块内存代表着一个引用。

 （1）强引用（Strong Reference）：如“Object obj = new Object（）”，这类引用是Java程序中最普遍的。只要强引用还存在，垃圾收集器就永远不会回收掉被引用的对象。

 （2）软引用（Soft Reference）：它用来描述一些可能还有用，但并非必须的对象。在系统内存不够用时，这类引用关联的对象将被垃圾收集器回收。JDK1.2之后提供了SoftReference类来实现软引用。

 （3）弱引用（Weak Reference）：它也是用来描述非须对象的，但它的强度比软引用更弱些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。在JDK1.2之后，提供了WeakReference类来实现弱引用。

 （4）虚引用（Phantom Reference）：最弱的一种引用关系，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的是希望能在这个对象被收集器回收时收到一个系统通知。JDK1.2之后提供了PhantomReference类来实现虚引用。 垃圾：无任何对象引用的对象。 判断对象是否是垃圾的算法： 引用计数算法（Reference Counting Collector）、根搜索算法（Tracing Collector）： 回收：清理“垃圾”占用的内存空间而非对象本身。 Tracing算法（Tracing Collector） 标记—清除算法：分为“标记”和“清除”两个阶段：首先标记出所需回收的对象，在标记完成后统一回收掉所有被标记的对象，它的标记过程其实就是前面的根搜索算法中判定垃圾对象的标记过程。 Compacting算法（Compacting Collector）标记—整理算法：标记的过程与标记—清除算法中的标记过程一样，但对标记后出的垃圾对象的处理情况有所不同，它不是直接对可回收对象进行清理，而是让所有的对象都向一端移动，然后直接清理掉端边界以外的内存。在基于Compacting算法的收集器的实现中，一般增加句柄和句柄表。 Copying算法（Copying Collector）：将内存按容量分为大小相等的两块，每次只使用其中的一块（对象面），当这一块的内存用完了，就将还存活着的对象复制到另外一块内存上面（空闲面），然后再把已使用过的内存空间一次清理掉。 Adaptive算法（Adaptive Collector）：监控当前堆的使用情况，并将选择适当算法的垃圾收集器。 发生地点：一般发生在堆内存中，因为大部分的对象都储存在堆内存中。 （堆内存为了配合垃圾回收有什么不同区域划分，各区域有什么不同？） Java的堆内存基于Generation算法（Generational Collector）划分为新生代、年老代和持久代。新生代又被进一步划分为Eden和Survivor区，最后Survivor由FromSpace（Survivor0）和ToSpace（Survivor1）组成。所有通过new创建的对象的内存都在堆中分配，其大小可以通过-Xmx和-Xms来控制。分代收集基于这样一个事实：不同的对象的生命周期是不一样的。因此，可以将不同生命周期的对象分代，不同的代采取不同的回收算法进行垃圾回收（GC），以便提高回收效率。 按执行机制划分Java有四种类型的垃圾回收器：

 （1）串行垃圾回收器（Serial Garbage Collector）

 （2）并行垃圾回收器（Parallel Garbage Collector）

 （3）并发标记扫描垃圾回收器（CMS Garbage Collector）

 （4）G1垃圾回收器（G1 Garbage Collector） 发生时间：程序空闲时间不定时回收。

# C语言关键字

#### 一、static 关键字的作用

答：
作用域方面：
1.限制变量的作用域（static全局变量）；
2.设置变量的存储域（static局部变量）。

static 最主要功能是隐藏，其次因为 static 变量存放在静态存储区，具备持久性和默认值为 0
①隐藏作用，可以在不同的文件中定义同名变量和同名函数。
②对于变量来说，保持变量持久，静态数据区的变量会在程序刚刚运行时就完成初始化，也是唯一一次初始化；储存在静态数据区，静态存储区只有两种变量（全局变量和 static 静态变量）。
③默认初始化为 0x00,和全局变量一样的属性，减少程序员的工作量。

###### 常见考题：

**1、static全局变量与普通的全局变量有什么区别？**
static全局变量只初使化一次，防止在其他文件单元中被引用;
**2、static局部变量和普通局部变量有什么区别？**
static局部变量只被初始化一次，下一次依据上一次结果值；
**3、static函数与普通函数有什么区别？**
static函数在内存中只有一份，普通函数在每个被调用中维持一份拷贝

#### 二、const 关键字的作用

答：
（1）==可以定义 const 常量 ==
（2）==const 可以修饰函数的参数、返回值，甚至函数的定义体。==被 const 修饰的东西都受到强制保护，可以预防意外的变动，能提高程序的健壮性。

#### 三、volatile 关键字的作用

编译器优化的介绍： 内存访问速度远远比不上 CPU处理的速度，为了提高性能， 从硬件上引入高速缓存 cache，加速对内存的访问。 编译优化的方法有：将内存变量缓存到寄存器；调整指令顺序充分利用 CPU 指 令流水线。
答：因为访问寄存器要比访问内存单元要快的多，编辑器会作减少存取的优化。
==当使用 volatile 声明函数变量的时候，系统总是重新从它所在的内存读取数据。 ==
遇到这个关键字声明的变量，编译器对访问该变量的代码不再进行优化，从而提 供对特殊地址的稳定访问； 如果不使用 valatile，编译器将对所声明的语句进行优化，以免出错。

###### volatile变量的几个例子：

1). 并行设备的硬件寄存器（如：状态寄存器）
2). 一个中断服务子程序中会访问到的非自动变量(Non-automatic variables)
3). 多线程应用中被几个任务共享的变量

#### 四、extern 关键字的作用

答：
引用一个已经定义过的全局变量
①函数内的局部变量，函数外定义的变量为全局变量，为静态存储方式，生存周期为整个程序，有效范围为定义变量的位置开始到本源文件结束。 如果在定义前想要引用该全局变量，则应该加上 extern 作为 “外部变量声明”。 多个源文件的工程想要引用一个源文件的外部变量也只许引用变量的文件中加 入 extern 关键字加以声明，但是可以在引用的模块内修改其变量的值，慎用。
②extern “C”: C++代码调用 C 语言代码。在 C++的头文件中使用。

# 请你说一下volatile

解题思路

一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，那么就具备了两层语义：

1）保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。

2）禁止进行指令重排序。 《深入理解Java虚拟机》中对volatile的描述：“观察加入volatile关键字和没有加入volatile关键字时所生成的汇编代码发现，加入volatile关键字时，会多出一个lock前缀指令” lock前缀指令实际上相当于一个内存屏障（也成内存栅栏），内存屏障会提供3个功能： 1）它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成；

 2）它会强制将对缓存的修改操作立即写入主存；

 3）如果是写操作，它会导致其他CPU中对应的缓存行无效。 因为volatile关键字无法保证操作的原子性。通常来说，使用volatile必须具备以下2个条件：

 1）对变量的写操作不依赖于当前值

 2）该变量没有包含在具有其他变量的不变式中

# 请你说一下内存泄漏

解题思路

当一个对象已经不需要再使用本该被回收时，另外一个正在使用的对象持有它的引用从而导致它不能被回收，这导致本该被回收的对象不能被回收而停留在堆内存中，这就产生了内存泄漏。内存泄漏是造成应用程序OOM的主要原因之一。我们知道Android系统为每个应用程序分配的内存是有限的，而当一个应用中产生的内存泄漏比较多时，这就难免会导致应用所需要的内存超过系统分配的内存限额，这就造成了内存溢出从而导致应用Crash。 常见的内存泄漏：

 1、单例造成的内存泄漏 由于单例的静态特性使得其生命周期和应用的生命周期一样长，如果一个对象已经不再需要使用了，而单例对象还持有该对象的引用，就会使得该对象不能被正常回收，从而导致了内存泄漏。

 2、非静态内部类创建静态实例造成的内存泄漏 非静态内部类默认会持有外部类的引用，而该非静态内部类又创建了一个静态的实例，该实例的生命周期和应用的一样长，这就导致了该静态实例一直会持有该Activity的引用，从而导致Activity的内存资源不能被正常回收。

 3、Handler造成的内存泄漏

 4、线程造成的内存泄漏 如果任务在Activity销毁之前还未完成，那么将导致Activity的内存资源无法被回收，从而造成内存泄漏。

 5、资源未关闭造成的内存泄漏 对于使用了BraodcastReceiver，ContentObserver，File，Cursor，Stream，Bitmap等资源，应该在Activity销毁时及时关闭或者注销，否则这些资源将不会被回收，从而造成内存泄漏。

 6、使用ListView时造成的内存泄漏

 7、集合容器中的内存泄露

 8、WebView造成的泄露 避免内存泄漏：

 1、在涉及使用Context时，对于生命周期比Activity长的对象应该使用Application的Context。

 2、对于需要在静态内部类中使用非静态外部成员变量（如：Context、View )，可以在静态内部类中使用弱引用来引用外部类的变量来避免内存泄漏。

 3、对于不再需要使用的对象，显示的将其赋值为null，比如使用完Bitmap后先调用recycle()，再赋为null。

 4、保持对对象生命周期的敏感，特别注意单例、静态对象、全局性集合等的生命周期。

 5、对于生命周期比Activity长的内部类对象，并且内部类中使用了外部类的成员变量，可以这样做避免内存泄漏：

 1）将内部类改为静态内部类

 2）静态内部类中使用弱引用来引用外部类的成员变量

# 请你说一下内存泄漏的原因

解题思路

当一个对象已经不需要再使用本该被回收时，另外一个正在使用的对象持有它的引用从而导致它不能被回收，这导致本该被回收的对象不能被回收而停留在堆内存中，这就产生了内存泄漏。内存泄漏是造成应用程序OOM的主要原因之一。我们知道Android系统为每个应用程序分配的内存是有限的，而当一个应用中产生的内存泄漏比较多时，这就难免会导致应用所需要的内存超过系统分配的内存限额，这就造成了内存溢出从而导致应用Crash。 常见的内存泄漏： 1、单例造成的内存泄漏 由于单例的静态特性使得其生命周期和应用的生命周期一样长，如果一个对象已经不再需要使用了，而单例对象还持有该对象的引用，就会使得该对象不能被正常回收，从而导致了内存泄漏。 2、非静态内部类创建静态实例造成的内存泄漏 非静态内部类默认会持有外部类的引用，而该非静态内部类又创建了一个静态的实例，该实例的生命周期和应用的一样长，这就导致了该静态实例一直会持有该Activity的引用，从而导致Activity的内存资源不能被正常回收。 3、Handler造成的内存泄漏 4、线程造成的内存泄漏 如果任务在Activity销毁之前还未完成，那么将导致Activity的内存资源无法被回收，从而造成内存泄漏。 5、资源未关闭造成的内存泄漏 对于使用了BraodcastReceiver，ContentObserver，File，Cursor，Stream，Bitmap等资源，应该在Activity销毁时及时关闭或者注销，否则这些资源将不会被回收，从而造成内存泄漏。 6、使用ListView时造成的内存泄漏 7、集合容器中的内存泄露 8、WebView造成的泄露 避免内存泄漏： 1、在涉及使用Context时，对于生命周期比Activity长的对象应该使用Application的Context。 2、对于需要在静态内部类中使用非静态外部成员变量（如：Context、View )，可以在静态内部类中使用弱引用来引用外部类的变量来避免内存泄漏。 3、对于不再需要使用的对象，显示的将其赋值为null，比如使用完Bitmap后先调用recycle()，再赋为null。 4、保持对对象生命周期的敏感，特别注意单例、静态对象、全局性集合等的生命周期。 5、对于生命周期比Activity长的内部类对象，并且内部类中使用了外部类的成员变量，可以这样做避免内存泄漏： 1）将内部类改为静态内部类 2）静态内部类中使用弱引用来引用外部类的成员变量

# 请你说一说强引用和弱引用

解题思路

强引用： 强引用是使用最普遍的引用。如果一个对象具有强引用，那垃圾回收器绝不会回收它。如下： Object o=new Object(); // 强引用 当内存空间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足的问题。如果不使用时，要通过如下方式来弱化引用，如下： o=null; // 帮助垃圾收集器回收此对象 显式地设置o为null，或超出对象的生命周期范围，则gc认为该对象不存在引用，这时就可以回收这个对象。具体什么时候收集这要取决于gc的算法。 举例： public void test(){ Object o=new Object(); } 在一个方法的内部有一个强引用，这个引用保存在栈中，而真正的引用内容（Object）保存在堆中。当这个方法运行完成后就会退出方法栈，则引用内容的引用不存在，这个Object会被回收。但是如果这个o是全局的变量时，就需要在不用这个对象时赋值为null，因为强引用不会被垃圾回收。 弱引用： 弱引用也是用来描述非必需对象的，只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程，因此不一定会很快发现那些只具有弱引用的对象。提供WeakReference类实现弱引用。 例子： String str=new String("abc"); WeakReference`<string>` abcWeakRef = new WeakReference`<string>`(str); str=null; 当垃圾回收器进行扫描回收时等价于： str = null; System.gc(); 如果这个对象是偶尔的使用，并且希望在使用时随时就能获取到，但又不想影响此对象的垃圾收集，那么你应该用Weak Reference 来记住此对象。 String abc = abcWeakRef.get(); //该代码会让str再次变为一个强引用： 弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。当你想引用一个对象，但是这个对象有自己的生命周期，你不想介入这个对象的生命周期，这时候你就是用弱引用。这个引用不会在对象的垃圾回收判断中产生任何附加的影响。`</string></string>`

# 请你说一下抽象类和接口的区别

解题思路

从语法层面来说，

１、抽象类可以提供成员方法的实现细节，而接口中只能存在抽象方法

２、抽象类中成员变量可以是多种类型，接口中成员变量必须用public，static，final修饰

３、一个类只能继承一个抽象类，但可以实现多个接口

４、抽象类中允许含有静态代码块和静态方法，接口不能 从设计层面而言

    1.抽象类是对整一个类的属性，行为等方面进行抽象，而接口则是对行为抽象。就好比飞机和鸟，抽象类抽象出的是飞行物类。而接口则是抽闲出飞行方法。

    2.抽象类是一个模板式的设计，当在开发过程中出现需求更改的情况，只需要更改抽象类而不需要更改它的子类。接口是一种辐射性设计，当接口的内容发生改变时，需要同时对实现它的子类进行相应的修改。

    3.抽象类可以类比为模板，而接口可以类比为协议

# 请你回答一下HTTP用的什么连接？

解题思路

在HTTP/1.0中，默认使用的是短连接。也就是说，浏览器和服务器每进行一次HTTP操作，就建立一次连接，但任务结束就中断连接。如果客户端浏览器访问的某个HTML或其他类型的 Web页中包含有其他的Web资源，如JavaScript文件、图像文件、CSS文件等；当浏览器每遇到这样一个Web资源，就会建立一个HTTP会话。 但从HTTP/1.1起，默认使用长连接，用以保持连接特性。使用长连接的HTTP协议，会在响应头有加入这行代码：Connection:keep-alive 在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的 TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接。Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长连接要客户端和服务端都支持长连接。

# 请你说一说TCP的流量控制

解题思路

滑动窗口机制： 滑动窗口协议的基本原理就是在任意时刻，发送方都维持了一个连续的允许发送的帧的序号，称为发送窗口；同时，接收方也维持了一个连续的允许接收的帧的序号，称为接收窗口。发送窗口和接收窗口的序号的上下界不一定要一样，甚至大小也可以不同。不同的滑动窗口协议窗口大小一般不同。发送方窗口内的序列号代表了那些已经被发送，但是还没有被确认的帧，或者是那些可以被发送的帧。 举例： 发送和接受方都会维护一个数据帧的序列，这个序列被称作窗口。发送方的窗口大小由接受方确定，目的在于控制发送速度，以免接受方的缓存不够大，而导致溢出，同时控制流量也可以避免网络拥塞。图中的4,5,6号数据帧已经被发送出去，但是未收到关联的ACK，7,8,9帧则是等待发送。可以看出发送端的窗口大小为6，这是由接受端告知的（事实上必须考虑拥塞窗口cwnd，这里暂且考虑cwnd>rwnd）。此时如果发送端收到4号ACK，则窗口的左边缘向右收缩，窗口的右边缘则向右扩展，此时窗口就向前“滑动了”，即数据帧10也可以被发送。

# 请你说一说DNS解析过程

解题思路

1、浏览器先检查自身缓存中有没有被解析过的这个域名对应的ip地址，如果有，解析结束。同时域名被缓存的时间也可通过TTL属性来设置。

 2、如果浏览器缓存中没有（专业点叫还没命中），浏览器会检查操作系统缓存中有没有对应的已解析过的结果。而操作系统也有一个域名解析的过程。在windows中可通过c盘里一个叫hosts的文件来设置，如果你在这里指定了一个域名对应的ip地址，那浏览器会首先使用这个ip地址。 但是这种操作系统级别的域名解析规程也被很多黑客利用，通过修改你的hosts文件里的内容把特定的域名解析到他指定的ip地址上，造成所谓的域名劫持。所以在windows7中将hosts文件设置成了readonly，防止被恶意篡改。

 3.如果至此还没有命中域名，才会真正的请求本地域名服务器（LDNS）来解析这个域名，这台服务器一般在你的城市的某个角落，距离你不会很远，并且这台服务器的性能都很好，一般都会缓存域名解析结果，大约80%的域名解析到这里就完成了。

 \4. 如果LDNS仍然没有命中，就直接跳到Root Server 域名服务器请求解析

 \5. 根域名服务器返回给LDNS一个所查询域的主域名服务器（gTLD Server，国际顶尖域名服务器，如.com .cn .org等）地址

 \6. 此时LDNS再发送请求给上一步返回的gTLD

 \7. 接受请求的gTLD查找并返回这个域名对应的Name Server的地址，这个Name Server就是网站注册的域名服务器

 \8. Name Server根据映射关系表找到目标ip，返回给LDNS

 \9. LDNS缓存这个域名和对应的ip 10. LDNS把解析的结果返回给用户，用户根据TTL值缓存到本地系统缓存中，域名解析过程至此结束

# 请你说一下常用设计模式

解题思路

（1）单例模式：保证一个类仅有一个实例，并提供一个访问它的全局访问点，避免一个全局使用的类频繁的创建和销毁，节省系统资源，提高程序效率。 实现方式： 将被实现的类的构造方法设计成private的。 添加此类引用的静态成员变量，并为其实例化。 在被实现的类中提供公共的Create Instance函数，返回实例化的此类,就是2中的静态成员变量。 单例模式只允许创建一个对象，因此节省内存，加快对象访问速度，适用场景： 需要频繁实例化然后销毁的对象。 创建对象时耗时过多或者耗资源过多，但又经常用到的对象。 有状态的工具类对象。 频繁访问数据库或文件的对象。 场景举例： 每台计算机有若干个打印机，但只能有一个PrinterSpooler，以避免两个打印作业同时输出到打印机； Windows的TaskManager（任务管理器），不能打开两个windows task manager； Windows的Recycle Bin（回收站），在整个系统运行过程中，回收站一直维护着仅有的一个实例； 网站的计数器，一般也是采用单例模式实现，否则难以同步；

 （2）策略模式：策略模式是把一个类中经常改变或者将来可能改变的部分提取出来作为一个接口，然后在类中包含这个对象的实例，这样类的实例在运行时就可以随意调用实现了这个接口的类的行为。 实现方式： 提供公共接口或抽象类，定义需要使用的策略方法。（策略抽象类） 多个实现的策略抽象类的实现类。（策略实现类） 环境类，对多个实现类的封装，提供接口类型的成员量，可以在客户端中切换。 客户端调用环境类进行不同策略的切换。 类图： Strategy：策略接口，用来约束一系列具体的策略算法。Context使用这个接口来调用具体的策略，实现定义的策略。 ConcreteStrategy：具体的策略实现，也就是具体的算法实现。 Context：上下文，负责与具体的策略交互，通常上下文会持有一个真正的策略实现。 适用场景： 如果在一个系统里面有许多类，它们之间的区别仅在于它们的行为，那么使用策略模式可以动态地让一个对象在许多行为中选择一种行为。 一个系统需要动态地在几种算法中选择一种。 一个类定义了多种行为, 并且这些行为在这个类的操作中以多个条件语句的形式出现。将相关的条件分支移入它们各自的Strategy类中以代替这些条件语句。

 （3）简单工厂模式：定义一个用于创建对象的接口或抽象类，让子类决定实例化哪一个类，工厂方法使一个类的实例化延迟到其子类。 类图： 实现方式: 抽象产品类（Product），是所创建的所有对象的父类，负责描述所有实例所共有的公共接口 多个具体的产品类（Concrete Product），具体产品角色是创建目标，所有创建的对象都充当这个角色的某个具体类的实例。 工厂类（Creator），负责实现创建所有实例的内部逻辑 适用场景： 在任何需要生成复杂对象的地方，都可以使用工厂方法模式。 当需要系统有比较好的扩展性时，可以考虑工厂模式，不同的产品用不同的实现工厂来组装。

 （4）装饰模式：允许向一个现有的对象添加新的功能，同时又不改变其结构，以在不使用创造更多子类的情况下，将对象的功能加以扩展。 类图： 实现方式: 抽象构件(Component)角色：给出一个抽象接口，以规范准备接收附加责任的对象。 具体构件(ConcreteComponent)角色：定义一个将要接收附加责任的类。 装饰(Decorator)角色：持有一个构件(Component)对象的实例，并定义一个与抽象构件接口一致的接口。 具体装饰(ConcreteDecorator)角色：负责给构件对象“贴上”附加的责任。 适用场景： 扩展一个类的功能。 动态增加功能，动态撤销。 （5）观察者模式：对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。 类图： 抽象主题(Subject)角色：把所有对观察者对象的引用保存在一个集合中，每个抽象主题角色都可以有任意数量的观察者。抽象主题提供一个接口，可以增加和删除观察者角色。一般用一个抽象类和接口来实现。 抽象观察者(Observer)角色：为所有具体的观察者定义一个接口，在得到主题的通知时更新自己。 具体主题(ConcreteSubject)角色：在具体主题内部状态改变时，给所有登记过的观察者发出通知。具体主题角色通常用一个子类实现。 具体观察者(ConcreteObserver)角色：该角色实现抽象观察者角色所要求的更新接口，以便使本身的状态与主题的状态相协调。通常用一个子类实现。如果需要，具体观察者角色可以保存一个指向具体主题角色的引用。 适用场景： 当一个抽象模型有两个方面, 其中一个方面依赖于另一方面。将这二者封装在独立的对象中以使它们可以各自独立地改变和复用。 当对一个对象的改变需要同时改变其它对象, 而不知道具体有多少对象有待改变。 当一个对象必须通知其它对象，而它又不能假定其它对象是谁。换言之, 你不希望这些对象是紧密耦合的。

# 请问设计模式是什么？

解题思路

设计模式（Design pattern）代表了最佳的实践，通常被有经验的面向对象的软件开发人员所采用。设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。 设计模式是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了重用代码、让代码更容易被他人理解、保证代码可靠性。毫无疑问，设计模式于己于他人于系统都是多赢的，设计模式使代码编制真正工程化，设计模式是软件工程的基石，如同大厦的一块块砖石一样。项目中合理地运用设计模式可以完美地解决很多问题，每种模式在现实中都有相应的原理来与之对应，每种模式都描述了一个在我们周围不断重复发生的问题，以及该问题的核心解决方案，这也是设计模式能被广泛应用的原因。

# 请问你有没有写过web测试，怎么写的？

解题思路

Web测试主要从下面几个大方向考虑 功能测试，主要做链接测试，表单测试，cookies测试，设计语言测试等 性能测试，考虑连接速度测试，以及负载测试，例如：Web应用系统能允许多少个用户同时在线？如果超过了这个数量，会出现什么现象？Web应用系统能否处理大量用户对同一个页面的请求？还有压力测试 可用性测试，比如导航测试，图形测试，内容测试，整体界面测试等 兼容性测试，市场上有很多不同的操作系统类型，最常见的有Windows、Unix、Macintosh、Linux等。Web应用系统的最终用户究竟使用哪一种操作系统，取决于用户系统的配置。这样，就可能会发生兼容性问题，同一个应用可能在某些操作系统下能正常运行，但在另外的操作系统下可能会运行失败。因此，在Web系统发布之前，需要在各种操作系统下对Web系统进行兼容性测试。 安全性测试， （1）现在的Web应用系统基本采用先注册，后登陆的方式。因此，必须测试有效和无效的用户名和密码，要注意到是否大小写敏感，可以试多少次的限制，是否可以不登陆而直接浏览某个页面等。 （2）Web应用系统是否有超时的限制，也就是说，用户登陆后在一定时间内（例如15分钟）没有点击任何页面，是否需要重新登陆才能正常使用。 （3）为了保证Web应用系统的安全性，日志文件是至关重要的。需要测试相关信息是否写进了日志文件、是否可追踪。 （4）当使用了安全套接字时，还要测试加密是否正确，检查信息的完整性。 （5）服务器端的脚本常常构成安全漏洞，这些漏洞又常常被黑客利用。所以，还要测试没有经过授权，就不能在服务器端放置和编辑脚本的问题。

# 请你说几个海量数据存储常见问题以及如何解答

解题思路

例子1：给你A,B两个文件，各存放50亿条URL，每条URL占用64字节，内存限制是4G，让你找出A,B文件共同的URL。 思路：可以估计每个文件安的大小为5G×64=320G，远远大于内存限制的4G。所以不可能将其完全加载到内存中处理。考虑采取分而治之的方法。 • 分而治之/hash映射：遍历文件a，对每个url求取，然后根据所取得的值将url分别存储到1000个小文件（记为）中。这样每个小文件的大约为300M。遍历文件b，采取和a相同的方式将url分别存储到1000小文件中（记为）。这样处理后，所有可能相同的url都在对应的小文件（）中，不对应的小文件不可能有相同的url。然后我们只要求出1000对小文件中相同的url即可。 • hash统计：求每对小文件中相同的url时，可以把其中一个小文件的url存储到hash_set中。然后遍历另一个小文件的每个url，看其是否在刚才构建的hash_set中，如果是，那么就是共同的url，存到文件里面就可以了。 例子2：有10个文件，每个文件1G， 每个文件的每一行都存放的是用户的query，每个文件的query都可能重复。要你按照query的频度排序 思路： • hash映射：顺序读取10个文件，按照hash(query)%10的结果将query写入到另外10个文件（记为）中。这样新生成的文件每个的大小大约也1G（假设hash函数是随机的）。 • hash统计：找一台内存在2G左右的机器，依次对用hash_map(query, query_count)来统计每个query出现的次数。注：hash_map(query,query_count)是用来统计每个query的出现次数，不是存储他们的值，出现一次，则count+1。 • 堆/快速/归并排序：利用快速/堆/归并排序按照出现次数进行排序。将排序好的query和对应的query_cout输出到文件中。这样得到了10个排好序的文件（记为）。对这10个文件进行归并排序（内排序与外排序相结合）。 例子3：有一个1G大小的一个文件，里面每一行是一个词，词的大小不超过16个字节，内存限制大小是1M。返回频数最高的100个词 思路： • 分而治之/hash映射：顺序读文件中，对于每个词x，取hash(x)%5000，然后按照该值存到5000个小文件（记为x0,x1,...x4999）中。这样每个文件大概是200k左右。如果其中的有的文件超过了1M大小，还可以按照类似的方法继续往下分，直到分解得到的小文件的大小都不超过1M。 • hash统计：对每个小文件，采用trie树/hash_map等统计每个文件中出现的词以及相应的频率。 • 堆/归并排序：取出出现频率最大的100个词（可以用含100个结点的最小堆），并把100个词及相应的频率存入文件，这样又得到了5000个文件。最后就是把这5000个文件进行归并（类似于归并排序）的过程了。 例子4：海量日志数据，提取出某日访问百度次数最多的那个IP。 思路： • 分而治之/hash映射：针对数据太大，内存受限，只能是：把大文件化成(取模映射)小文件，即16字方针：大而化小，各个击破，缩小规模，逐个解决 • hash统计：当大文件转化了小文件，那么我们便可以采用常规的Hashmap(ip，value)来进行频率统计。 • 堆/快速排序：统计完了之后，便进行排序(可采取堆排序)，得到次数最多的IP。

# 请问多线程是什么？

解题思路

最开始，线程只是用于分配单个处理器的处理时间的一种工具。但假如操作系统本身支持多个处理器，那么每个线程都可分配给一个不同的处理器，真正进入“并行运算”状态。从程序设计语言的角度看，多线程操作最有价值的特性之一就是程序员不必关心到底使用了多少个处理器。程序在逻辑意义上被分割为数个线程;假如机器本身安装了多个处理器，那么程序会运行得更快，毋需作出任何特殊的调校。根据前面的论述，大家可能感觉线程处理非常简单。但必须注意一个问题：共享资源!如果有多个线程同时运行，而且它们试图访问相同的资源，就会遇到一个问题。举个例子来说，两个线程不能将信息同时发送给一台打印机。为解决这个问题，对那些可共享的资源来说(比如打印机)，它们在使用期间必须进入锁定状态。所以一个线程可将资源锁定，在完成了它的任务后，再解开(释放)这个锁，使其他线程可以接着使用同样的资源。 多线程是为了同步完成多项任务，不是为了提高运行效率，而是为了提高资源使用效率来提高系统的效率。线程是在同一时间需要完成多项任务的时候实现的。 一个采用了多线程技术的应用程序可以更好地利用系统资源。其主要优势在于充分利用了CPU的空闲时间片，可以用尽可能少的时间来对用户的要求做出响应，使得进程的整体运行效率得到较大提高，同时增强了应用程序的灵活性。更为重要的是，由于同一进程的所有线程是共享同一内存，所以不需要特殊的数据传送机制，不需要建立共享存储区或共享文件，从而使得不同任务之间的协调操作与运行、数据的交互、资源的分配等问题更加易于解决。

# 请问你有没有做过什么单元测试，怎么进行单元测试，对一个没有参数没有返回值但可能对全局变量有影响的怎么进行单元测试

解题思路

如何进行单元测试： １、创建单元测试，该工具可以对任何类、接口、结构等实体中的字段、属性、构造函数、方法等进行单元测试。创建单元测试大致可以分为两类： 整体测试，整体测试是在类名称上右击鼠标，在下拉菜单中点击创建单元测试选项。这样就可以为整个类创建单元测试了，这时他会为整个类可以被测试的内容全部添加测试方法。开发人员直接在这些自动生成的测试方法中添加单元测试代码就可以了。 单独测试，如果只想单独对某个方法、属性、字段进行测试，则可以将鼠标焦点放在这个待测试的项目名称之上，然后点击鼠标右键，在右键菜单中选择创建单元测试选项。这样就可以单独为某个方法创建单元测试了。 运行单元测试 查看测试结果 编写单元测试代码 测试没有参数的函数，它可能还有别的输入，例如全局变量，成员变量，或调用子函数获得的输入（这个要使用工具才能做到），只要函数需读取的，都应该设定初始值，如果完全没有，没有输入也是一种输入，照样测试就是了。同样道理，输出也不仅仅是返回值，没有返回值还可能修改了全局变量什么的，这些也是要判断的输出。

# 什么是踩内存

访问了不合法的地址 。通俗一点就是访问了不属于自己的地址。如果这块地址分配给了另一个变量使用，就会破坏别人的数据。从而导致程序运行异常，挂死，输出图像破图等。

2.踩内存的可能的情形
1）内存访问越界

    a)数组访问越界；

    b)字符串操作越界；

2）非法指针

    a）使用了空指针；

    b)使用了释放掉的指针；

    c)指针类型转换错误；

3）栈溢出；

4）多线程读写的数据没有加锁保护

5）多线程使用了线程不安全的函数

3.如何排查
1）删减模块代码，缩小排查范围；

2）加log，打印内存地址/值；

3）将被踩内存设置成只读，在调用栈中查看谁在写；

还有一些结合内核分析的高级手段，待学习

4.如何避免
写代码时严格遵守编程规范。

1）数组访问边界检查，防止溢出，关于数组大小等关键数值使用宏代替；

2）使用strcpy,strcat,sprintf,strcmp,strcasecmp等字符串操作函数需谨慎，可以以使用strncpy,strlcpy,strncat,strlcat,snprintf,strncmp,strncasecmp等代替防止读写越界；

memcpy在内存重叠时不保证拷贝是正确的，memmove在内存重叠时保证拷贝是正确的；

3）指针释放后及时置空，必要时使用指针非空检查；

4）不要定义过大的局部变量，例如数组，容易造成栈溢出；

5）变量定义好后及时赋初值，特别像结构体这种；

6）代码嵌套适量，防止资源重复申请/释放；

7）多线程时做好线程保护；
